📘 디지털공학 관점에서 본 PCM · 샘플링 · 비트깊이 · 버퍼 정리
1️⃣ `아날로그 → 디지털의 출발점`
- **아날로그 신호**

* 시간에 대해 연속적
* 소리, 전압, 센서 값 등
* 👉 컴퓨터는 연속값 처리 ❌ 
* 👉 숫자(이산값) 로 바꿔야 함

2️⃣ `**PCM** (Pulse Code Modulation)의 본질`

* PCM = 연속 신호를 “숫자 배열”로 바꾸는 규칙

* 디지털공학적으로 보면:

* PCM = 정수 배열 + 시간 간격 규칙

3️⃣ `샘플링 (Sampling) — 시간 축의 이산화
정의`

* 연속적인 시간 신호를 일정한 시간 간격으로 측정

* 샘플링 주파수 (Hz)

  - 1초에 몇 번 측정하는가

  - 예: 44.1kHz = 1초에 44,100번

* 디지털공학적 의미

  - 시간을 균등한 슬롯으로 나눔

  - 시간 → 인덱스

  - t = n / Fs

  - sample[n]  // n번째 시간 슬롯


👉 “1초를 샘플링 수만큼 나눈다”는 표현은 정확함

4️⃣ `비트 깊이 (Bit Depth) — 값 축의 이산화
정의`

* 각 샘플(진폭 하나)을 몇 비트로 표현할 것인가


- **디지털공학적 의미**

  - 진폭의 연속 범위를 유한한 단계로 나눔

  - 이 과정이 바로 양자화(Quantization)

예시
16bit PCM

단계 수:

2^16 = 65,536


표현 범위:

-32768 ~ +32767


👉 진폭 하나 → 이 단계 중 하나에 “할당”

5️⃣ **핵심 개념 요약 (이게 제일 중요)**

|  구분   | 무엇을 나누는가 |
|:-----:|:--------:|
|  샘플링  |    시간    |
| 비트 깊이 |  진폭(값)   |

6️⃣ **메모리 관점에서의 PCM (핵심 전환 포인트)**

PCM을 이해하는 가장 강력한 관점:

short pcm[44100];   


배열 길이 = 샘플링 개수 (시간)

배열 원소 = 진폭

자료형 크기 = 비트 깊이

👉 PCM은 그냥 정수 배열이다

7️⃣ **왜 “버퍼”가 필연적으로 등장하는가**

현실의 문제

아날로그 입력: 연속

CPU 처리: 불연속

출력 장치: 일정 속도 요구

👉 속도 불일치 발생

8️⃣ **버퍼(Buffer)의 정의**

버퍼 = 일정 개수의 샘플을 임시로 쌓아두는 메모리

short buffer[1024];


연속 입력을 덩어리 단위로 처리

인터럽트/콜백 단위

9️⃣ **버퍼 크기 = 시간 분기점**

버퍼는 디지털공학적으로:

연속 시간을 “처리 단위 시간”으로 자르는 기준

공식
버퍼 시간(ms) = (버퍼 크기 / 샘플링 주파수) × 1000

예: 44.1kHz 기준
버퍼 크기	시간
1024	약 23ms
512	약 11.6ms
256	약 5.8ms

👉 버퍼 크기 조절 = ms 단위 지연 조절

🔟 **작은 버퍼 vs 큰 버퍼 (트레이드오프)**

작은 버퍼

지연 ↓

CPU 부담 ↑

끊김 위험 ↑

큰 버퍼

지연 ↑

CPU 부담 ↓

안정성 ↑

1️⃣1️⃣ **최종 연결 (디지털공학 핵심 관점)**

아날로그 신호

↓

샘플링 (시간 이산화)

↓

양자화 (값 이산화)

↓

정수 배열 (PCM)

↓

버퍼 단위 처리

↓

실시간 시스템

✅ **최종 한 문장 요약 (이거 기억하면 끝)**

PCM은 “시간 축으로 인덱싱된 정수 배열”이고,
샘플링은 시간을 나누고,
비트 깊이는 값을 나누며,
버퍼는 그 배열을 처리하는 시간 단위다.