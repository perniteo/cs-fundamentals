# InnoDB / Index / DB 설계 핵심 정리

## 1. InnoDB의 기본 전제
- InnoDB는 **항상 클러스터드 인덱스 기반 스토리지 엔진**
- 테이블 = 클러스터드 인덱스
- 데이터는 반드시 **어떤 기준(PK)** 으로 정렬되어 저장됨

### PK가 없으면?
- InnoDB가 내부적으로 **hidden row_id** 생성
- row_id 기준으로 클러스터드 인덱스 구성
- → 설계 통제권 상실 → 명시적 PK가 항상 더 낫다

---

## 2. 클러스터드 인덱스 vs 보조 인덱스

### 클러스터드 인덱스 (PK)
- PK 기준 **B+Tree**
- 리프 노드에 **데이터 자체**가 저장됨
- PK 조회 = 트리 탐색 + 바로 데이터 접근
- Range 조회 빠름 (연속 리프 노드)

### 보조 인덱스 (Secondary Index)
- PK가 아닌 컬럼에 생성
- 리프 노드에 **PK 값** 저장
- 조회 흐름:
    1. 보조 인덱스에서 PK 획득
    2. PK 인덱스로 이동
    3. 데이터 접근
- → **2단계 탐색**

---

## 3. 인덱스 페이지 / 데이터 페이지
- 인덱스 페이지 ≠ 데이터 페이지
- 클러스터드 인덱스에서는:
    - 리프 노드 = 데이터 페이지
- 보조 인덱스에서는:
    - 리프 노드 = (인덱스 키 + PK)

---

## 4. B+Tree 때문에 풀스캔이 아닌 이유

### 핵심
- PK의 “물리 위치”를 미리 아는 게 아님
- **B+Tree 구조가 값의 범위를 좁혀가며 안내**

### PK 조회 흐름
1. 루트 노드
2. 브랜치 노드
3. 리프 노드 (딱 하나)
   → O(log N)

### 따라서
- 클러스터드 인덱스를 쓴다고 해서 풀스캔 ❌
- **전부 읽을 때만** 풀스캔 ⭕️

---

## 5. InnoDB에서의 풀스캔
- InnoDB에도 풀스캔은 존재
- 의미:
    - **클러스터드 인덱스 리프 노드를 처음부터 끝까지 읽는 것**
- 실행계획상:
    - `type=ALL`
- 디스크 관점에서는:
    - 순차 I/O (디스크가 제일 잘하는 작업)

---

## 6. Read / Write 성능 차이 이유

### 조회(Read)가 빠른 이유
- 정렬된 구조
- 순차 접근 가능
- 트리 구조 변경 없음
- 캐시 효율 높음

### 쓰기(Write)가 비싼 이유
- 정렬 유지 필요
- 페이지 분할(Page Split) 가능
- 모든 보조 인덱스 갱신 필요
- UPDATE는 내부적으로 DELETE + INSERT

### 결론
- Read = 이미 정렬된 걸 읽기
- Write = 정렬된 구조를 유지하며 수정

---

## 7. PK 설계가 중요한 이유
- PK = 클러스터드 인덱스 기준
- PK 선택이 곧:
    - 데이터 물리 배치
    - Range 성능
    - Write 성능
    - 보조 인덱스 비용

### 좋은 PK
- AUTO_INCREMENT
- 단조 증가
- 변경 없음

### 나쁜 PK
- UUID (랜덤)
- 자주 바뀌는 값
- 의미 없는 복합키

---

## 8. 정규화 핵심 사고
- 정규화는 규칙 암기가 아님
- 기준 질문:
  > 이 컬럼은 PK 하나로 완전히 설명되는가?

- YES → 같은 테이블
- NO → 분리

- PK는 정규화 대상 ❌
- PK는 **정규화의 기준점**

---

## 9. 주문 / 고객 / 주소 설계
- customers.address
    - 고객의 현재 주소
- orders.shipping_address
    - 주문 당시 배송 주소 (스냅샷)

→ 의미가 다르므로 중복 아님

---

## 10. 주문 수정 원칙
- 주문 = 이벤트 → 원칙적으로 불변
- 배송 주소:
    - 상태에 따라 제한적 수정 가능
- 변경은 UPDATE
- 변경 이력은 별도 테이블로 관리

---

## 11. 백엔드에서 DB 설계의 위치
- API: 갈아끼우기 가능
- DB 스키마: 한번 틀리면 갈아엎기 지옥

> 코드 변경 = 작업  
> DB 변경 = 사건
